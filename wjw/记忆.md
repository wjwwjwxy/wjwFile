## 问答

### 一、vue的运行机制（源码）：双向绑定，虚拟dom

​    **Vue 使用Object.defineProperty + 观察者模式对数据和模版进行绑定**

   + $data 转发到this(第一次get、set)

   + 模板编译、更新（文档碎片的创建vue 1.0中的实现方式），处理**绑定变量**时创建watcher，获取当前模板的初始值，在读取时触发数据的getter函数进行dep中添加watcher实例，后续触发setter根据记录的watcher更新模板内容

     ```javascript
     let TARGET = null;
     // 策略模式处理模板中的指令、事件以及{{}}
     const utils = {
       // 获取data中的值
       getValue(expr, vm) {
         return vm.$data[expr.trim()];
       },
       // 设置data中的值
       setValue(expr, vm, newValue) {
         vm.$data[expr] = newValue;
       },
       // 处理v-model双向绑定
       model(node, value, vm) {
         const initValue = this.getValue(value, vm);
         new Watcher(value, vm, (newValue) => {
           this.modelUpdater(node, newValue);
         });
     
         node.addEventListener('input', (e) => {
           const newValue = e.target.value;
           this.setValue(value, vm, newValue);
         });
     
         this.modelUpdater(node, initValue);
       },
       // 处理v-text 和 {{}}
       text(node, value, vm) {
         let result;
         if (value.includes('{{')) {
           // {{ xxx }}
           result = value.replace(/\{\{(.+?)\}\}/g, (...args) => {
             const expr = args[1];
             new Watcher(expr, vm, (newVal) => {
               this.textUpdater(node, newVal);
             })
             return this.getValue(args[1], vm);
           });
         } else {
           // v-text="xxx"
           result = this.getValue(value, vm);
         }
     
         this.textUpdater(node, result);
       },
       // 处理监听事件
       on(node, value, vm, eventName) {
         const fn = vm.$options.methods[value];
         node.addEventListener(eventName, fn.bind(vm), false);
       },
       textUpdater(node, value) {
         node.textContent = value;
       },
       modelUpdater(node, value) {
         node.value = value;
       }
     }
     
     // 一个 DOM 节点的依赖及更新 观察者
     class Watcher {
       constructor(expr, vm, cb) {
         this.expr = expr;
         this.vm = vm;
         this.cb = cb;
         // 通过 getter 对数据进行绑定，标记当前的 watcher
         this.oldValue = this.getOldValue();
       }
     
       getOldValue() {
         TARGET = this;
         // 通过 getter 读取当前依赖
         const oldValue = utils.getValue(this.expr, this.vm);
         TARGET = null;
         return oldValue;
       }
     
       update() {
         const newValue = utils.getValue(this.expr, this.vm);
         if (newValue !== this.oldValue) {
           this.cb(newValue);
         }
       }
     }
     
     // 一个数据 key 的多个 watcher 依赖 订阅者Dep
     class Dep {
       constructor() {
         this.collect = [];
       }
     
       addWatcher(watcher) {
         this.collect.push(watcher);
       }
     
       notify() {
         this.collect.forEach(w => w.update());
       }
     }
     // Vue 1.0中的模板编译
     class Compiler {
       constructor(el, vm) {
         this.el = this.isElementNode(el) ? el : document.querySelector(el);
         this.vm = vm;
     
         const fragment = this.compileFragment(this.el);
     
         this.compile(fragment);
         this.el.appendChild(fragment);
       }
     
       compile(fragment) {
         const childNodes = Array.from(fragment.childNodes);
         childNodes.forEach(childNode => {
           if (this.isElementNode(childNode)) {
             // 标签节点 h1 / input，读取属性，查看是否有 v- 开头的内容
             this.compileElement(childNode);
     
           } else if (this.isTextNode(childNode)) {
             // 内容文本节点 {{ msg }} 是否有双括号语法
             this.compileText(childNode);
           }
     
           if (childNode.childNodes && childNode.childNodes.length) {
             this.compile(childNode);
           }
         });
       }
     
       compileElement(node) {
         // v-model v-text v-on:click
         const attributes = Array.from(node.attributes);
         attributes.forEach(attr => {
           const { name, value } = attr;
           if (this.isDirector(name)) {
             // 指令 v-model, v-text, v-bind, v-on:click
             const [, directive] = name.split('-');
             const [compileKey, eventName] = directive.split(':');
             utils[compileKey](node, value, this.vm, eventName);
           } else if (this.isEventName(name)) {
             // @ 方法执行
             const [, eventName] = name.split('@');
             utils['on'](node, value, this.vm, eventName);
           }
         })
       }
     
       isDirector(name) {
         return name.startsWith('v-');
       }
     
       isEventName(name) {
         return name.startsWith('@');
       }
     
       compileText(node) {
         // {{ msg }}
         const content = node.textContent;
         if (/\{\{(.+)\}\}/.test(content)) {
           utils['text'](node, content, this.vm);
         }
       }
     
       compileFragment(el) {
         const f = document.createDocumentFragment();
         let firstChild;
         while(firstChild = el.firstChild) {
           f.appendChild(firstChild);
         }
         return f;
       }
     
       isTextNode(el) {
         return el.nodeType === 3;
       }
     
       isElementNode(el) {
         return el.nodeType === 1;
       }
     }
      // 通过defineProperty给data中的对象绑定get方法
     class Observer {
       constructor(data) {
         this.observe(data);
       }
     
       observe(data) {
         if (data && typeof data === 'object') {
           Object.keys(data).forEach(key => {
             this.defineReactive(data, key, data[key]);
           })
         }
       }
     
       defineReactive(obj, key, value) {
         this.observe(value);
         const dep = new Dep();
         Object.defineProperty(obj, key, {
           get() {
             const target = TARGET;
             // 收集watcher，第一次触犯get是在模板编译的过程中
             TARGET && dep.addWatcher(target);
             return value;
           },
           set: (newVal) => {
             if (value === newVal) return;
             this.observe(newVal);
             value = newVal;
             // 更新每一个Watcher
             dep.notify();
           }
         })
       }
     }
     
     class Vue {
       constructor(options) {
         this.$el = options.el;
         this.$data = options.data;
         this.$options = options;
     
         // 触发 this.$data.xx 和模版的绑定
         new Observer(this.$data);
         // 处理模版部分，将模版中使用的 data 部分的变量和模版绑定起来
         new Compiler(this.$el, this);
     
         this.proxyData(this.$data)
       }
     
       // 可以通过 this.xx 更改 this.$data.xx 的结果
       proxyData(data) {
         Object.keys(data).forEach(key => {
           Object.defineProperty(this, key, {
             get() {
               return data[key];
             },
             set(newVal) {
               data[key] = newVal;
             }
           });
         })
       }
     }
     ```

   + **对于数组而言大部分操作Object.defineProperty是拦截不到的，vue内部重写了相关的方法**

   + vNode中核心patch方法（textNode,对比children【新增、删除、更新（diff）】）

   + diff算法详解（patch方法内部逻辑）

     ```javascript
     // 入参有新老两个 VNode 以及父节点的 element
     function patch (oldVnode, vnode, parentElm) {
         if (!oldVnode) {
             /*  首先在 `oldVnode`（老 VNode 节点）不存在的时候，相当于新的 VNode 替代原本没有的节点，所以直接用 `addVnodes` 将这些节点批量添加到 `parentElm` 上。 */
             addVnodes(parentElm, null, vnode, 0, vnode.length - 1);
         } else if (!vnode) {
             /*在 `vnode`（新 VNode 节点）不存在的时候，相当于要把老的节点删除，所以直接使用 `removeVnodes` 进行批量的节点删除即可*/
             removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);
         } else {
             /*当 `oldVNode` 与 `vnode` 都存在的时候，需要判断它们是否属于 `sameVnode`（相同的节点）,如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点*/
             if (sameVnode(oldVNode, vnode)) {
                 /*`sameVnode` 其实很简单，只有当 `key`、 `tag`、 `isComment`（是否为注释节点）、 `data`同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同*/
                 patchVnode(oldVNode, vnode);
             } else {
                 removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);
                 addVnodes(parentElm, null, vnode, 0, vnode.length - 1);
             }
         }
     }
     
     function patchVnode (oldVnode, vnode) {
         if (oldVnode === vnode) {
             return;
         }
         /*在当新老 VNode 节点都是 `isStatic`（静态的），并且 `key` 相同时，只要将 `componentInstance` 与 `elm` 从老 VNode 节点“拿过来”即可*/
         if (vnode.isStatic && oldVnode.isStatic && vnode.key === oldVnode.key) {
             vnode.elm = oldVnode.elm;
             vnode.componentInstance = oldVnode.componentInstance;
             return;
         }
         const elm = vnode.elm = oldVnode.elm;
         const oldCh = oldVnode.children;
         const ch = vnode.children;
         /*当新 VNode 节点是文本节点的时候，直接用 `setTextContent` 来设置 text,nodeOps适配函数*/
         if (vnode.text) {
             nodeOps.setTextContent(elm, vnode.text);
         } else {
             if (oldCh && ch && (oldCh !== ch)) {
                 /*`oldCh` 与 `ch` 都存在且不相同时，使用 `updateChildren` 函数来更新子节点*/
                 updateChildren(elm, oldCh, ch);
             } else if (ch) {
                 /*如果只有 `ch` 存在的时候，如果老节点是文本节点则先将节点的文本清除，然后将 `ch` 批量插入插入到节点elm下*/
                 if (oldVnode.text) nodeOps.setTextContent(elm, '');
                 addVnodes(elm, null, ch, 0, ch.length - 1);
             } else if (oldCh) {
                 /*当只有 `oldch` 存在时，说明需要将老节点通过 `removeVnodes` 全部清除*/
                 removeVnodes(elm, oldCh, 0, oldCh.length - 1)
             } else if (oldVnode.text) {
                 /*最后一种情况是当只有老节点是文本节点的时候，清除其节点文本内容*/
                 nodeOps.setTextContent(elm, '')
             }
         }
     }
     
     function updateChildren (parentElm, oldCh, newCh) {
         /*定义 `oldStartIdx`、`newStartIdx`、`oldEndIdx` 以及 `newEndIdx` 分别是新老两个 VNode 的两边的索引，同时 `oldStartVnode`、`newStartVnode`、`oldEndVnode` 以及 `newEndVnode` 分别指向这几个索引对应的 VNode 节点*/
         let oldStartIdx = 0;
         let newStartIdx = 0;
         let oldEndIdx = oldCh.length - 1;
         let oldStartVnode = oldCh[0];
         let oldEndVnode = oldCh[oldEndIdx];
         let newEndIdx = newCh.length - 1;
         let newStartVnode = newCh[0];
         let newEndVnode = newCh[newEndIdx];
         let oldKeyToIdx, idxInOld, elmToMove, refElm;
         // `oldStartIdx`、`newStartIdx`、`oldEndIdx` 以及 `newEndIdx` 会逐渐向中间靠拢
         while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
             if (!oldStartVnode) {
                 /*当 `oldStartVnode` 不存在的时候，`oldStartIdx` 继续向中间靠拢，并更新对应的 `oldStartVnode` 的指向*/
                 oldStartVnode = oldCh[++oldStartIdx];
             } else if (!oldEndVnode) {
                 /*当`oldEndVnode` 不存在的时候，`oldEndIdx` 继续向中间靠拢，并更新对应的`oldEndVnode` 的指向*/
                 oldEndVnode = oldCh[--oldEndIdx];
             } else if (sameVnode(oldStartVnode, newStartVnode)) {
                 /*`oldStartVnode` 与 `newStartVnode` 符合 `sameVnode` 时，说明老 VNode 节点的头部与新 VNode 节点的头部是相同的 VNode 节点，直接递归进行 `patchVnode`，同时 `oldStartIdx` 与 `newStartIdx` 向后移动一位*/
                 patchVnode(oldStartVnode, newStartVnode);
                 oldStartVnode = oldCh[++oldStartIdx];
                 newStartVnode = newCh[++newStartIdx];
             } else if (sameVnode(oldEndVnode, newEndVnode)) {
                 /*`oldEndVnode` 与 `newEndVnode` 符合 `sameVnode`，也就是两个 VNode 的结尾是相同的 VNode，同样递归进行 `patchVnode` 操作并将 `oldEndVnode` 与 `newEndVnode` 向前移动一位*/
                 patchVnode(oldEndVnode, newEndVnode);
                 oldEndVnode = oldCh[--oldEndIdx];
                 newEndVnode = newCh[--newEndIdx];
             } else if (sameVnode(oldStartVnode, newEndVnode)) {
                 /*`oldStartVnode` 与 `newEndVnode` 符合 `sameVnode` 的时候，也就是老 VNode 节点的头部与新 VNode 节点的尾部是同一节点的时候，将 `oldStartVnode.elm` 这个节点直接移动到 `oldEndVnode.elm` 这个节点的后面即可。然后 `oldStartIdx` 向后移动一位，`newEndIdx` 向前移动一位*/
                 patchVnode(oldStartVnode, newEndVnode);
                 nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                 oldStartVnode = oldCh[++oldStartIdx];
                 newEndVnode = newCh[--newEndIdx];
             } else if (sameVnode(oldEndVnode, newStartVnode)) {
                 /*`oldEndVnode` 与 `newStartVnode` 符合 `sameVnode` 时，也就是老 VNode 节点的尾部与新 VNode 节点的头部是同一节点的时候，将 `oldEndVnode.elm` 插入到 `oldStartVnode.elm` 前面。同样的，`oldEndIdx` 向前移动一位，`newStartIdx` 向后移动一位*/
                 patchVnode(oldEndVnode, newStartVnode);
                 nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                 oldEndVnode = oldCh[--oldEndIdx];
                 newStartVnode = newCh[++newStartIdx];
             } else {
                 let elmToMove = oldCh[idxInOld];
                 // `createKeyToOldIdx` 的作用是产生 `key` 与 `index` 索引对应的一个 map 表
                 if (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                 // 从旧节点列表生成的map表中寻找与当前新节点列表的start节点相同节点
                 idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : null;
                 if (!idxInOld) {
                     /* 如果没有找到，通过 `createElm` 创建一个新节点，并将 `newStartIdx` 向后移动一位*/
                     createElm(newStartVnode, parentElm);
                     newStartVnode = newCh[++newStartIdx];
                 } else {
                     /*如果找到了节点，同时它符合 `sameVnode`，则将这两个节点进行 `patchVnode`，将该位置的老节点赋值 undefined（之后如果还有新节点与该节点key相同可以检测出来提示已有重复的 key ），同时将 `newStartVnode.elm` 插入到 `oldStartVnode.elm` 的前面。同理，`newStartIdx` 往后移动一位*/
                     elmToMove = oldCh[idxInOld];
                     if (sameVnode(elmToMove, newStartVnode)) {
                         patchVnode(elmToMove, newStartVnode);
                         oldCh[idxInOld] = undefined;
                         nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
                         newStartVnode = newCh[++newStartIdx];
                     } else {
                         /* 如果不符合 `sameVnode`，只能创建一个新节点插入到 `parentElm` 的子节点中，`newStartIdx` 往后移动一位 */
                         createElm(newStartVnode, parentElm);
                         newStartVnode = newCh[++newStartIdx];
                     }
                 }
             }
         }
     
         if (oldStartIdx > oldEndIdx) {
             /* 当 `while` 循环结束以后，如果 `oldStartIdx > oldEndIdx`，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 `addVnodes` 将这些节点插入即可*/
             refElm = (newCh[newEndIdx + 1]) ? newCh[newEndIdx + 1].elm : null;
             addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);
         } else if (newStartIdx > newEndIdx) {
             /*如果满足 `newStartIdx > newEndIdx` 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 `removeVnodes` 批量删除即可*/
             removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
         }
     }
     function createKeyToOldIdx (children, beginIdx, endIdx) {
         let i, key
         const map = {}
         for (i = beginIdx; i <= endIdx; ++i) {
             key = children[i].key
             if (isDef(key)) map[key] = i
         }
         return map
     }
     ```


### 二、webpack配置流程

+ 基础配置案例

     ```javascript
     const path = require('path')
     const UglifyPlugin = require('uglifyjs-webpack-plugin')
     
     module.exports = {
       entry: './src/index.js',
     
       output: {
         path: path.resolve(__dirname, 'dist'),
         filename: 'bundle.js',
       },
     
       module: {
         rules: [
           {
             test: /\.jsx?/,
             include: [
               path.resolve(__dirname, 'src')
             ],
             use: 'babel-loader',
           },
         ],
       },
     
       // 代码模块路径解析的配置
       // 在 webpack 配置中，和模块路径解析相关的配置都在 `resolve` 字段下
       resolve: {
         modules: [
           "node_modules",
           path.resolve(__dirname, 'src')
         ],
     
         extensions: [".wasm", ".mjs", ".js", ".json", ".jsx"],
       },
     
       plugins: [
         new UglifyPlugin(), 
         // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码
         // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了JS 代码压缩的插件
         // 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数
       ],
     }
     ```

+ 常用plugin和loader等

     html-webpack-plugin（可以将我们的页面和构建 JS 关联起来）

     style-loader（将 css-loader 解析的结果转变成 JS 代码，运行时动态插入 `style` 标签来让 CSS 代码生效）

     css-loader（处理 CSS 中的依赖，例如 `@import` 和 `url()`）

     babel-loader（转换高版本js至低版本）

     extract-text-webpack-plugin（分离css和js）

     less-loader（处理less）

     file-loader（处理图片文件）

     webpack-dev-server（本地的静态服务）

     DefinePlugin（创建一些在编译时可以配置的全局常量）

     copy-webpack-plugin（就是用来复制文件的）

     ProvidePlugin（引用某些模块作为应用运行时的变量，从而不必每次都用 `require` 或者 `import`）

     IgnorePlugin（忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去）

+ webpack 模块（resolve相关配置）

     *解析规则【解析相对路径：查找相对当前模块的路径下是否有对应文件或文件夹>>>是文件则直接加载>>>是文件夹则继续查找文件夹下的 package.json 文件>>>有 package.json 文件则按照文件中 `main` 字段的文件名来查找文件>>>无 package.json 或者无 `main` 字段则查找 `index.js` 文件
     解析模块名 ：查找当前文件目录下，父级目录及以上目录下的 `node_modules` 文件夹，看是否有对应名称的模块
     解析绝对路径（不建议使用）：直接查找对应路径的文件】*

     `resolve.alias`：匹配常用（多复用）模块

     ```javascript
     alias: {
       utils$: path.resolve(__dirname, 'src/utils') // 只会匹配 import 'utils'
     }
     ```

     `resolve.extensions`：匹配文件类型的优先级

     ```javascript
     extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'],
     // 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js
     ```

     `resolve.modules`：对于直接声明依赖名的模块，配置node\_modules的

     `resolve.mainFields`： 当引用的是一个模块或者一个目录时，会使用 package.json 文件的哪一个字段下指定的文件**？？？**

     `resolve.mainFiles`：配置目录下没有package.json时使用的文件，默认是index.js

     `resolve.resolveLoader`：配置解析 loader 时的 resolve 配置

+ loader配置

     *   `{ test: ... }` 匹配特定条件
     *   `{ include: ... }` 匹配特定路径
     *   `{ exclude: ... }` 排除特定路径
     *   `{ and: [...] }`必须匹配数组中所有条件
     *   `{ or: [...] }` 匹配数组中任意一个条件
     *   `{ not: [...] }` 排除匹配数组中所有条件
     *   一个模块文件可以经过多个 loader 的转换处理，执行顺序是从最后配置的 loader 开始，一步步往前
     *   `module.noParse` 字段，可以用于配置哪些模块文件的内容不需要进行解析。对于一些**不需要解析依赖（即无依赖）** 的第三方大型类库等，可以通过这个字段来配置

+ plugin使用

+ webpack-dev-server 的使用

     *可以通过 `devServer` 字段来配置 webpack-dev-server，如端口设置、启动 gzip 压缩等`devServer`有以下基础配置字段*

     `public` 字段用于指定静态服务的域名

     `port` 字段用于指定静态服务的端口，如上，默认是 8080

     `publicPath` 字段用于指定构建好的静态文件在浏览器中用什么路径去访问

     > 建议将 `devServer.publicPath` 和 `output.publicPath` 的值保持一致。
>
     > `publicPath` 的优先级高于 `contentBase`。

     `proxy` 用于配置 webpack-dev-server 将特定 URL 的请求代理到另外一台服务器上
    
     `before` 和 `after` 配置用于在 webpack-dev-server 定义额外的中间件

+ webpack相关优化
  
  图片加载优化
  
  代码压缩
  
  分离代码文件有效利用缓存（webpack 4.x 的 `optimization`）
  
  如何在 webpack 中实现按需加载模块
  
+ webpack工作流程
  
  ```
  创建 Compiler -> 
  调用 compiler.run 开始构建 ->
  创建 Compilation -> 
  基于配置开始创建 Chunk -> 
  使用 Parser 从 Chunk 开始解析依赖 -> 
  使用 Module 和 Dependency 管理代码模块相互关系 -> 
  使用 Template 基于 Compilation 的数据生成结果代码
  
  ```
  
     

### 三、性能优化相关（回流和重绘、防抖和节流、懒加载如何实现图懒加载等）

### 四、vue基础（组件通信，key的作用，生命周期，插槽）包括路由和vuex

+ **路由原理：**

   > hash模式：通过修改location.hash以及监听hashChange
   >
   > history模式：通过监听popstate

### 五、浏览器输入url之后发生了什么

### 六、http和https(主要的字段含义)

### 七、tcp/ip

### 八、js基础（数据类型、es6、原型链、闭包、promise）

+ **数据类型**
1. 6 种原始值 `boolean`、`null`、`undefined`、`number`、`string`、`symbol`
2. 对象（object）类型
+ **es6相关**

+ **原型链**

1. 原型链就是多个对象通过 `__proto__` 的方式连接了起来

   p1.\_\_proto\_\_ === Player.prototype

   Player.prototype.\_\_proto\_\_ === Function.prototype

   Function.prototype.\_\_proto\_\_ === Object.prototype

2. new 做了些什么

   1. 一个继承自 Player 的新对象 p1 被创建了。

   2. p1.\_\_proto\_\_ = Player.prototype，p1 的\_\_proto\_\_指向 Player 的原型对象

   3. 将 this 指向新创建的对象 p1

   4. 返回这个新对象 p1
      4.1 未显式 return, 返回新对象 p1
      4.2 显式 return this, 返回新对象 p1
      4.3 显示 return 基本类型, 返回新对象 p1

      4.4 显示 return 对象类型（比如一个空对象）, 返回一个空对象。

    

+ **闭包**
1. 定义：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包
2. 使用场景：事件的回调，模拟类的私有方法，封装上下文变量
+ **promise**
+ 

### 九、html5新增，css动画

### 十、vue3中的proxy解决了什么问题



## 测试

### 算法（排序，最大公约数）

### 事件代理等
