#### 问答

1. vue的运行机制（源码）：双向绑定，虚拟dom

​    **Vue 使用Object.defineProperty + 观察者模式对数据和模版进行绑定**

   + $data 转发到this(第一次get、set)

   + 模板编译、更新（文档碎片的创建vue 1.0中的实现方式），处理**绑定变量**时创建watcher，获取当前模板的初始值，在读取时触发数据的getter函数进行dep中添加watcher实例，后续触发setter根据记录的watcher更新模板内容

   + **对于数组而言大部分操作Object.defineProperty是拦截不到的，vue内部重写了相关的方法**

   + vNode中核心patch方法（textNode,对比children【新增、删除、更新（diff）】）




2. webpack配置流程

+ 基础配置案例

     ```javascript
     const path = require('path')
     const UglifyPlugin = require('uglifyjs-webpack-plugin')
     
     module.exports = {
       entry: './src/index.js',
     
       output: {
         path: path.resolve(__dirname, 'dist'),
         filename: 'bundle.js',
       },
     
       module: {
         rules: [
           {
             test: /\.jsx?/,
             include: [
               path.resolve(__dirname, 'src')
             ],
             use: 'babel-loader',
           },
         ],
       },
     
       // 代码模块路径解析的配置
       // 在 webpack 配置中，和模块路径解析相关的配置都在 `resolve` 字段下
       resolve: {
         modules: [
           "node_modules",
           path.resolve(__dirname, 'src')
         ],
     
         extensions: [".wasm", ".mjs", ".js", ".json", ".jsx"],
       },
     
       plugins: [
         new UglifyPlugin(), 
         // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码
         // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了JS 代码压缩的插件
         // 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数
       ],
     }
     ```

+ 常用plugin和loader等

     html-webpack-plugin（可以将我们的页面和构建 JS 关联起来）

     style-loader（将 css-loader 解析的结果转变成 JS 代码，运行时动态插入 `style` 标签来让 CSS 代码生效）

     css-loader（处理 CSS 中的依赖，例如 `@import` 和 `url()`）

     babel-loader（转换高版本js至低版本）

     extract-text-webpack-plugin（分离css和js）

     less-loader（处理less）

     file-loader（处理图片文件）

     webpack-dev-server（本地的静态服务）

     DefinePlugin（创建一些在编译时可以配置的全局常量）

     copy-webpack-plugin（就是用来复制文件的）

     ProvidePlugin（引用某些模块作为应用运行时的变量，从而不必每次都用 `require` 或者 `import`）

     IgnorePlugin（忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去）

+ webpack 模块（resolve相关配置）

     *解析规则【解析相对路径：查找相对当前模块的路径下是否有对应文件或文件夹>>>是文件则直接加载>>>是文件夹则继续查找文件夹下的 package.json 文件>>>有 package.json 文件则按照文件中 `main` 字段的文件名来查找文件>>>无 package.json 或者无 `main` 字段则查找 `index.js` 文件
     解析模块名 ：查找当前文件目录下，父级目录及以上目录下的 `node_modules` 文件夹，看是否有对应名称的模块
     解析绝对路径（不建议使用）：直接查找对应路径的文件】*

     `resolve.alias`：匹配常用（多复用）模块

     ```javascript
     alias: {
       utils$: path.resolve(__dirname, 'src/utils') // 只会匹配 import 'utils'
     }
     ```

     `resolve.extensions`：匹配文件类型的优先级

     ```javascript
     extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'],
     // 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js
     ```

     `resolve.modules`：对于直接声明依赖名的模块，配置node\_modules的

     `resolve.mainFields`： 当引用的是一个模块或者一个目录时，会使用 package.json 文件的哪一个字段下指定的文件**？？？**

     `resolve.mainFiles`：配置目录下没有package.json时使用的文件，默认是index.js

     `resolve.resolveLoader`：配置解析 loader 时的 resolve 配置

+ loader配置

     *   `{ test: ... }` 匹配特定条件
     *   `{ include: ... }` 匹配特定路径
     *   `{ exclude: ... }` 排除特定路径
     *   `{ and: [...] }`必须匹配数组中所有条件
     *   `{ or: [...] }` 匹配数组中任意一个条件
     *   `{ not: [...] }` 排除匹配数组中所有条件
     *   一个模块文件可以经过多个 loader 的转换处理，执行顺序是从最后配置的 loader 开始，一步步往前
     *   `module.noParse` 字段，可以用于配置哪些模块文件的内容不需要进行解析。对于一些**不需要解析依赖（即无依赖）** 的第三方大型类库等，可以通过这个字段来配置

+ plugin使用

+ webpack-dev-server 的使用

     *可以通过 `devServer` 字段来配置 webpack-dev-server，如端口设置、启动 gzip 压缩等`devServer`有以下基础配置字段*

     `public` 字段用于指定静态服务的域名

     `port` 字段用于指定静态服务的端口，如上，默认是 8080

     `publicPath` 字段用于指定构建好的静态文件在浏览器中用什么路径去访问

     > 建议将 `devServer.publicPath` 和 `output.publicPath` 的值保持一致。

     `proxy` 用于配置 webpack-dev-server 将特定 URL 的请求代理到另外一台服务器上

     > `publicPath` 的优先级高于 `contentBase`。

     `before` 和 `after` 配置用于在 webpack-dev-server 定义额外的中间件
     
+ webpack相关优化
  
  图片加载优化
  
  代码压缩
  
  分离代码文件有效利用缓存（webpack 4.x 的 `optimization`）
  
  如何在 webpack 中实现按需加载模块
  
+ webpack工作流程
  
  ```
  创建 Compiler -> 
  调用 compiler.run 开始构建 ->
  创建 Compilation -> 
  基于配置开始创建 Chunk -> 
  使用 Parser 从 Chunk 开始解析依赖 -> 
  使用 Module 和 Dependency 管理代码模块相互关系 -> 
  使用 Template 基于 Compilation 的数据生成结果代码
  
  ```
  
  
  
     

3. 性能优化相关（回流和重绘、防抖和节流、懒加载如何实现图懒加载等）

4. vue基础（组件通信，key的作用，生命周期）包括路由和vuex

   路由原理：

   > hash模式：通过修改location.hash以及监听hashChange
   >
   > history模式：通过监听popstate

5. 浏览器输入url之后发生了什么

6. http和https(主要的字段含义)

7. tcp/ip

8. js基础（数据类型、es6、原型链、闭包、promise）

9. html5新增，css动画

10. vue3中的proxy解决了什么问题





#### 测试

1. 算法（排序，最大公约数）
2. 事件代理等