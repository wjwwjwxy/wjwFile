## 问答

### 一、vue的运行机制（源码）：双向绑定，虚拟dom

​**Vue 使用Object.defineProperty + 观察者模式对数据和模版进行绑定**

   + $data 转发到this(第一次get、set)

   + 模板编译、更新（文档碎片的创建vue 1.0中的实现方式），处理**绑定变量**时创建watcher，获取当前模板的初始值，在读取时触发数据的getter函数进行dep中添加watcher实例，后续触发setter根据记录的watcher更新模板内容

     ```javascript
     let TARGET = null;
     // 策略模式处理模板中的指令、事件以及{{}}
     const utils = {
       // 获取data中的值
       getValue(expr, vm) {
         return vm.$data[expr.trim()];
       },
       // 设置data中的值
       setValue(expr, vm, newValue) {
         vm.$data[expr] = newValue;
       },
       // 处理v-model双向绑定
       model(node, value, vm) {
         const initValue = this.getValue(value, vm);
         new Watcher(value, vm, (newValue) => {
           this.modelUpdater(node, newValue);
         });
     
         node.addEventListener('input', (e) => {
           const newValue = e.target.value;
           this.setValue(value, vm, newValue);
         });
     
         this.modelUpdater(node, initValue);
       },
       // 处理v-text 和 {{}}
       text(node, value, vm) {
         let result;
         if (value.includes('{{')) {
           // {{ xxx }}
           result = value.replace(/\{\{(.+?)\}\}/g, (...args) => {
             const expr = args[1];
             new Watcher(expr, vm, (newVal) => {
               this.textUpdater(node, newVal);
             })
             return this.getValue(args[1], vm);
           });
         } else {
           // v-text="xxx"
           result = this.getValue(value, vm);
         }
     
         this.textUpdater(node, result);
       },
       // 处理监听事件
       on(node, value, vm, eventName) {
         const fn = vm.$options.methods[value];
         node.addEventListener(eventName, fn.bind(vm), false);
       },
       textUpdater(node, value) {
         node.textContent = value;
       },
       modelUpdater(node, value) {
         node.value = value;
       }
     }
     
     // 一个 DOM 节点的依赖及更新 观察者
     class Watcher {
       constructor(expr, vm, cb) {
         this.expr = expr;
         this.vm = vm;
         this.cb = cb;
         // 通过 getter 对数据进行绑定，标记当前的 watcher
         this.oldValue = this.getOldValue();
       }
     
       getOldValue() {
         TARGET = this;
         // 通过 getter 读取当前依赖
         const oldValue = utils.getValue(this.expr, this.vm);
         TARGET = null;
         return oldValue;
       }
     
       update() {
         const newValue = utils.getValue(this.expr, this.vm);
         if (newValue !== this.oldValue) {
           this.cb(newValue);
         }
       }
     }
     
     // 一个数据 key 的多个 watcher 依赖 订阅者Dep
     class Dep {
       constructor() {
         this.collect = [];
       }
     
       addWatcher(watcher) {
         this.collect.push(watcher);
       }
     
       notify() {
         this.collect.forEach(w => w.update());
       }
     }
     // Vue 1.0中的模板编译
     class Compiler {
       constructor(el, vm) {
         this.el = this.isElementNode(el) ? el : document.querySelector(el);
         this.vm = vm;
     
         const fragment = this.compileFragment(this.el);
     
         this.compile(fragment);
         this.el.appendChild(fragment);
       }
     
       compile(fragment) {
         const childNodes = Array.from(fragment.childNodes);
         childNodes.forEach(childNode => {
           if (this.isElementNode(childNode)) {
             // 标签节点 h1 / input，读取属性，查看是否有 v- 开头的内容
             this.compileElement(childNode);
     
           } else if (this.isTextNode(childNode)) {
             // 内容文本节点 {{ msg }} 是否有双括号语法
             this.compileText(childNode);
           }
     
           if (childNode.childNodes && childNode.childNodes.length) {
             this.compile(childNode);
           }
         });
       }
     
       compileElement(node) {
         // v-model v-text v-on:click
         const attributes = Array.from(node.attributes);
         attributes.forEach(attr => {
           const { name, value } = attr;
           if (this.isDirector(name)) {
             // 指令 v-model, v-text, v-bind, v-on:click
             const [, directive] = name.split('-');
             const [compileKey, eventName] = directive.split(':');
             utils[compileKey](node, value, this.vm, eventName);
           } else if (this.isEventName(name)) {
             // @ 方法执行
             const [, eventName] = name.split('@');
             utils['on'](node, value, this.vm, eventName);
           }
         })
       }
     
       isDirector(name) {
         return name.startsWith('v-');
       }
     
       isEventName(name) {
         return name.startsWith('@');
       }
     
       compileText(node) {
         // {{ msg }}
         const content = node.textContent;
         if (/\{\{(.+)\}\}/.test(content)) {
           utils['text'](node, content, this.vm);
         }
       }
     
       compileFragment(el) {
         const f = document.createDocumentFragment();
         let firstChild;
         while(firstChild = el.firstChild) {
           f.appendChild(firstChild);
         }
         return f;
       }
     
       isTextNode(el) {
         return el.nodeType === 3;
       }
     
       isElementNode(el) {
         return el.nodeType === 1;
       }
     }
      // 通过defineProperty给data中的对象绑定get方法
     class Observer {
       constructor(data) {
         this.observe(data);
       }
     
       observe(data) {
         if (data && typeof data === 'object') {
           Object.keys(data).forEach(key => {
             this.defineReactive(data, key, data[key]);
           })
         }
       }
     
       defineReactive(obj, key, value) {
         this.observe(value);
         const dep = new Dep();
         Object.defineProperty(obj, key, {
           get() {
             const target = TARGET;
             // 收集watcher，第一次触犯get是在模板编译的过程中
             TARGET && dep.addWatcher(target);
             return value;
           },
           set: (newVal) => {
             if (value === newVal) return;
             this.observe(newVal);
             value = newVal;
             // 更新每一个Watcher
             dep.notify();
           }
         })
       }
     }
     
     class Vue {
       constructor(options) {
         this.$el = options.el;
         this.$data = options.data;
         this.$options = options;
     
         // 触发 this.$data.xx 和模版的绑定
         new Observer(this.$data);
         // 处理模版部分，将模版中使用的 data 部分的变量和模版绑定起来
         new Compiler(this.$el, this);
     
         this.proxyData(this.$data)
       }
     
       // 可以通过 this.xx 更改 this.$data.xx 的结果
       proxyData(data) {
         Object.keys(data).forEach(key => {
           Object.defineProperty(this, key, {
             get() {
               return data[key];
             },
             set(newVal) {
               data[key] = newVal;
             }
           });
         })
       }
     }
     ```

   + **对于数组而言大部分操作Object.defineProperty是拦截不到的，vue内部重写了相关的方法**

   + vNode中核心patch方法（textNode,对比children【新增、删除、更新（diff）】）

   + diff算法详解（patch方法内部逻辑）

     ```javascript
     // 入参有新老两个 VNode 以及父节点的 element
     function patch (oldVnode, vnode, parentElm) {
         if (!oldVnode) {
             /*  首先在 `oldVnode`（老 VNode 节点）不存在的时候，相当于新的 VNode 替代原本没有的节点，所以直接用 `addVnodes` 将这些节点批量添加到 `parentElm` 上。 */
             addVnodes(parentElm, null, vnode, 0, vnode.length - 1);
         } else if (!vnode) {
             /*在 `vnode`（新 VNode 节点）不存在的时候，相当于要把老的节点删除，所以直接使用 `removeVnodes` 进行批量的节点删除即可*/
             removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);
         } else {
             /*当 `oldVNode` 与 `vnode` 都存在的时候，需要判断它们是否属于 `sameVnode`（相同的节点）,如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点*/
             if (sameVnode(oldVNode, vnode)) {
                 /*`sameVnode` 其实很简单，只有当 `key`、 `tag`、 `isComment`（是否为注释节点）、 `data`同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同*/
                 patchVnode(oldVNode, vnode);
             } else {
                 removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);
                 addVnodes(parentElm, null, vnode, 0, vnode.length - 1);
             }
         }
     }
     
     function patchVnode (oldVnode, vnode) {
         if (oldVnode === vnode) {
             return;
         }
         /*在当新老 VNode 节点都是 `isStatic`（静态的），并且 `key` 相同时，只要将 `componentInstance` 与 `elm` 从老 VNode 节点“拿过来”即可*/
         if (vnode.isStatic && oldVnode.isStatic && vnode.key === oldVnode.key) {
             vnode.elm = oldVnode.elm;
             vnode.componentInstance = oldVnode.componentInstance;
             return;
         }
         const elm = vnode.elm = oldVnode.elm;
         const oldCh = oldVnode.children;
         const ch = vnode.children;
         /*当新 VNode 节点是文本节点的时候，直接用 `setTextContent` 来设置 text,nodeOps适配函数*/
         if (vnode.text) {
             nodeOps.setTextContent(elm, vnode.text);
         } else {
             if (oldCh && ch && (oldCh !== ch)) {
                 /*`oldCh` 与 `ch` 都存在且不相同时，使用 `updateChildren` 函数来更新子节点*/
                 updateChildren(elm, oldCh, ch);
             } else if (ch) {
                 /*如果只有 `ch` 存在的时候，如果老节点是文本节点则先将节点的文本清除，然后将 `ch` 批量插入插入到节点elm下*/
                 if (oldVnode.text) nodeOps.setTextContent(elm, '');
                 addVnodes(elm, null, ch, 0, ch.length - 1);
             } else if (oldCh) {
                 /*当只有 `oldch` 存在时，说明需要将老节点通过 `removeVnodes` 全部清除*/
                 removeVnodes(elm, oldCh, 0, oldCh.length - 1)
             } else if (oldVnode.text) {
                 /*最后一种情况是当只有老节点是文本节点的时候，清除其节点文本内容*/
                 nodeOps.setTextContent(elm, '')
             }
         }
     }
     
     function updateChildren (parentElm, oldCh, newCh) {
         /*定义 `oldStartIdx`、`newStartIdx`、`oldEndIdx` 以及 `newEndIdx` 分别是新老两个 VNode 的两边的索引，同时 `oldStartVnode`、`newStartVnode`、`oldEndVnode` 以及 `newEndVnode` 分别指向这几个索引对应的 VNode 节点*/
         let oldStartIdx = 0;
         let newStartIdx = 0;
         let oldEndIdx = oldCh.length - 1;
         let oldStartVnode = oldCh[0];
         let oldEndVnode = oldCh[oldEndIdx];
         let newEndIdx = newCh.length - 1;
         let newStartVnode = newCh[0];
         let newEndVnode = newCh[newEndIdx];
         let oldKeyToIdx, idxInOld, elmToMove, refElm;
         // `oldStartIdx`、`newStartIdx`、`oldEndIdx` 以及 `newEndIdx` 会逐渐向中间靠拢
         while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
             if (!oldStartVnode) {
                 /*当 `oldStartVnode` 不存在的时候，`oldStartIdx` 继续向中间靠拢，并更新对应的 `oldStartVnode` 的指向*/
                 oldStartVnode = oldCh[++oldStartIdx];
             } else if (!oldEndVnode) {
                 /*当`oldEndVnode` 不存在的时候，`oldEndIdx` 继续向中间靠拢，并更新对应的`oldEndVnode` 的指向*/
                 oldEndVnode = oldCh[--oldEndIdx];
             } else if (sameVnode(oldStartVnode, newStartVnode)) {
                 /*`oldStartVnode` 与 `newStartVnode` 符合 `sameVnode` 时，说明老 VNode 节点的头部与新 VNode 节点的头部是相同的 VNode 节点，直接递归进行 `patchVnode`，同时 `oldStartIdx` 与 `newStartIdx` 向后移动一位*/
                 patchVnode(oldStartVnode, newStartVnode);
                 oldStartVnode = oldCh[++oldStartIdx];
                 newStartVnode = newCh[++newStartIdx];
             } else if (sameVnode(oldEndVnode, newEndVnode)) {
                 /*`oldEndVnode` 与 `newEndVnode` 符合 `sameVnode`，也就是两个 VNode 的结尾是相同的 VNode，同样递归进行 `patchVnode` 操作并将 `oldEndVnode` 与 `newEndVnode` 向前移动一位*/
                 patchVnode(oldEndVnode, newEndVnode);
                 oldEndVnode = oldCh[--oldEndIdx];
                 newEndVnode = newCh[--newEndIdx];
             } else if (sameVnode(oldStartVnode, newEndVnode)) {
                 /*`oldStartVnode` 与 `newEndVnode` 符合 `sameVnode` 的时候，也就是老 VNode 节点的头部与新 VNode 节点的尾部是同一节点的时候，将 `oldStartVnode.elm` 这个节点直接移动到 `oldEndVnode.elm` 这个节点的后面即可。然后 `oldStartIdx` 向后移动一位，`newEndIdx` 向前移动一位*/
                 patchVnode(oldStartVnode, newEndVnode);
                 nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                 oldStartVnode = oldCh[++oldStartIdx];
                 newEndVnode = newCh[--newEndIdx];
             } else if (sameVnode(oldEndVnode, newStartVnode)) {
                 /*`oldEndVnode` 与 `newStartVnode` 符合 `sameVnode` 时，也就是老 VNode 节点的尾部与新 VNode 节点的头部是同一节点的时候，将 `oldEndVnode.elm` 插入到 `oldStartVnode.elm` 前面。同样的，`oldEndIdx` 向前移动一位，`newStartIdx` 向后移动一位*/
                 patchVnode(oldEndVnode, newStartVnode);
                 nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                 oldEndVnode = oldCh[--oldEndIdx];
                 newStartVnode = newCh[++newStartIdx];
             } else {
                 let elmToMove = oldCh[idxInOld];
                 // `createKeyToOldIdx` 的作用是产生 `key` 与 `index` 索引对应的一个 map 表
                 if (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                 // 从旧节点列表生成的map表中寻找与当前新节点列表的start节点相同节点
                 idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : null;
                 if (!idxInOld) {
                     /* 如果没有找到，通过 `createElm` 创建一个新节点，并将 `newStartIdx` 向后移动一位*/
                     createElm(newStartVnode, parentElm);
                     newStartVnode = newCh[++newStartIdx];
                 } else {
                     /*如果找到了节点，同时它符合 `sameVnode`，则将这两个节点进行 `patchVnode`，将该位置的老节点赋值 undefined（之后如果还有新节点与该节点key相同可以检测出来提示已有重复的 key ），同时将 `newStartVnode.elm` 插入到 `oldStartVnode.elm` 的前面。同理，`newStartIdx` 往后移动一位*/
                     elmToMove = oldCh[idxInOld];
                     if (sameVnode(elmToMove, newStartVnode)) {
                         patchVnode(elmToMove, newStartVnode);
                         oldCh[idxInOld] = undefined;
                         nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
                         newStartVnode = newCh[++newStartIdx];
                     } else {
                         /* 如果不符合 `sameVnode`，只能创建一个新节点插入到 `parentElm` 的子节点中，`newStartIdx` 往后移动一位 */
                         createElm(newStartVnode, parentElm);
                         newStartVnode = newCh[++newStartIdx];
                     }
                 }
             }
         }
     
         if (oldStartIdx > oldEndIdx) {
             /* 当 `while` 循环结束以后，如果 `oldStartIdx > oldEndIdx`，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 `addVnodes` 将这些节点插入即可*/
             refElm = (newCh[newEndIdx + 1]) ? newCh[newEndIdx + 1].elm : null;
             addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);
         } else if (newStartIdx > newEndIdx) {
             /*如果满足 `newStartIdx > newEndIdx` 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 `removeVnodes` 批量删除即可*/
             removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
         }
     }
     function createKeyToOldIdx (children, beginIdx, endIdx) {
         let i, key
         const map = {}
         for (i = beginIdx; i <= endIdx; ++i) {
             key = children[i].key
             if (isDef(key)) map[key] = i
         }
         return map
     }
     ```

### 二、webpack配置流程

+ 相关基础
1. 定义：模块打包工具(Module Bundler)
2. 模块化类型：ES Module、commonJS、AMD、CMD

+ 基础配置案例

     ```javascript
     const path = require('path')
     const UglifyPlugin = require('uglifyjs-webpack-plugin')
     
     module.exports = {
       entry: './src/index.js',
     
       output: {
         path: path.resolve(__dirname, 'dist'),
         filename: 'bundle.js',
       },
       // 在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules
       module: {
         rules: [
           {
             test: /\.jsx?/,
             include: [
               path.resolve(__dirname, 'src')
             ],
             use: 'babel-loader',
           },
         ],
       },
     
       // 代码模块路径解析的配置
       // 在 webpack 配置中，和模块路径解析相关的配置都在 `resolve` 字段下
       resolve: {
         modules: [
           "node_modules",
           path.resolve(__dirname, 'src')
         ],
     
         extensions: [".wasm", ".mjs", ".js", ".json", ".jsx"],
       },
     
       plugins: [
         new UglifyPlugin(), 
         // 使用 uglifyjs-webpack-plugin 来压缩 JS 代码
         // 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了JS 代码压缩的插件
         // 这其实也是我们命令中的 --mode production 的效果
       ],
     }
     ```
+ sourceMap（webpack的devTool配置项）
1. 概念：是一个映射关系（打包后的代码和原始代码的对应关系）

+ 常用plugin和loader等

     html-webpack-plugin（可以将我们的页面和构建 JS 关联起来）

     style-loader（将 css-loader 解析的结果转变成 JS 代码，运行时动态插入 `style` 标签来让 CSS 代码生效）

     css-loader（处理 CSS 中的依赖，例如 `@import` 和 `url()`）

     babel-loader（转换高版本js至低版本）

     extract-text-webpack-plugin（分离css和js）

     less-loader（处理less）

     file-loader（处理图片文件）

     webpack-dev-server（本地的静态服务）

     DefinePlugin（创建一些在编译时可以配置的全局常量）

     copy-webpack-plugin（就是用来复制文件的）

     ProvidePlugin（引用某些模块作为应用运行时的变量，从而不必每次都用 `require` 或者 `import`）

     IgnorePlugin（忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去）

+ webpack 模块（resolve相关配置）

     *解析规则【解析相对路径：查找相对当前模块的路径下是否有对应文件或文件夹>>>是文件则直接加载>>>是文件夹则继续查找文件夹下的 package.json 文件>>>有 package.json 文件则按照文件中 `main` 字段的文件名来查找文件>>>无 package.json 或者无 `main` 字段则查找 `index.js` 文件
     解析模块名 ：查找当前文件目录下，父级目录及以上目录下的 `node_modules` 文件夹，看是否有对应名称的模块
     解析绝对路径（不建议使用）：直接查找对应路径的文件】*

     `resolve.alias`：匹配常用（多复用）模块

     ```javascript
     alias: {
       utils$: path.resolve(__dirname, 'src/utils') // 只会匹配 import 'utils'
     }
     ```

     `resolve.extensions`：匹配文件类型的优先级

     ```javascript
     extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx']
     // 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js
     ```

     `resolve.modules`：对于直接声明依赖名的模块，配置node\_modules的

     `resolve.mainFields`： 当引用的是一个模块或者一个目录时，会使用 package.json 文件的哪一个字段下指定的文件**？？？**

     `resolve.mainFiles`：配置目录下没有package.json时使用的文件，默认是index.js

     `resolve.resolveLoader`：配置解析 loader 时的 resolve 配置

+ loader配置

     *   `{ test: ... }` 匹配特定条件
     *   `{ include: ... }` 匹配特定路径
     *   `{ exclude: ... }` 排除特定路径
     *   `{ and: [...] }`必须匹配数组中所有条件
     *   `{ or: [...] }` 匹配数组中任意一个条件
     *   `{ not: [...] }` 排除匹配数组中所有条件
     *   一个模块文件可以经过多个 loader 的转换处理，执行顺序是从**最后配置的 loader 开始，一步步往前**
     *   `module.noParse` 字段，可以用于配置哪些模块文件的内容不需要进行解析。对于一些**不需要解析依赖（即无依赖）** 的第三方大型类库等，可以通过这个字段来配置

+ plugin使用

+ webpack-dev-server 的使用

     *可以通过 `devServer` 字段来配置 webpack-dev-server，如端口设置、启动 gzip 压缩等`devServer`有以下基础配置字段*

     `public` 字段用于指定静态服务的域名

     `port` 字段用于指定静态服务的端口，如上，默认是 8080

     `publicPath` 字段用于指定构建好的静态文件在浏览器中用什么路径去访问

     建议将 `devServer.publicPath` 和 `output.publicPath` 的值保持一致。

     `publicPath` 的优先级高于 `contentBase`。

     `proxy` 用于配置 webpack-dev-server 将特定 URL 的请求代理到另外一台服务器上
    
     `before` 和 `after` 配置用于在 webpack-dev-server 定义额外的中间件

+ webpack相关优化
  
  图片加载优化
  
  代码压缩
  
  分离代码文件有效利用缓存（webpack 4.x 的 `optimization`）
  
  如何在 webpack 中实现按需加载模块
  
+ webpack工作流程
  
  ```
  创建 Compiler -> 
  调用 compiler.run 开始构建 ->
  创建 Compilation -> 
  基于配置开始创建 Chunk -> 
  使用 Parser 从 Chunk 开始解析依赖 -> 
  使用 Module 和 Dependency 管理代码模块相互关系 -> 
  使用 Template 基于 Compilation 的数据生成结果代码
  
  ```

### 三、性能优化相关（回流和重绘、防抖和节流、懒加载如何实现图懒加载等）
+ **浏览器性能指标 performanceAPI 做性能分析相关的事、浏览器 devTool 中查看相关性能指标（内存等）**
+ **相关优化总体思路**
1. 加速或减少HTTP请求消耗
2. 延迟加载
3. 减少请求内容体积（gzip）
4. 浏览器渲染原理
5. 优化用户等待体验
6. 从垃圾回收考虑优化
    1. 数组array优化
        ~~~ javascript
          arr.length = 0  // 可以直接让数字清空，而且数组类型不变。
          // arr = []; 虽然让a变量成一个空数组,但是在堆上重新申请了一个空数组对象。并且将原来的数组对象变成了一小片内存垃圾
        ~~~
    2. 对象尽量复用
    3. 在循环中的函数表达式，能复用最好放到循环外面。

+ **回流和重绘**
1. 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建-----回流
2. 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color-----重绘

+ **防抖和节流**
1. 开发过程中需要绑定一些持续触发的事件，如 `resize、scroll、mousemove` 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。
2. 防抖：就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间（分为立即执行和非立即执行）
    ~~~javascript
   /**
    * @desc 函数防抖
    * @param func 函数
    * @param wait 延迟执行毫秒数
    * @param immediate true 表立即执行，false 表非立即执行
    */
   function debounce(func,wait,immediate) {
       let timeout;
   
       return function () {
           let context = this;
           let args = arguments;
   
           if (timeout) clearTimeout(timeout);
           if (immediate) {
               var callNow = !timeout;
               timeout = setTimeout(() => {
                   timeout = null;
               }, wait)
               if (callNow) func.apply(context, args)
           }
           else {
               timeout = setTimeout(function(){
                   func.apply(context, args)
               }, wait);
           }
       }
   }
   ~~~
3. 节流：就是指连续触发事件但是在 n 秒中只执行一次函数（会降低函数的执行频率）
    ~~~javascript
    /**
     * @desc 函数节流
     * @param func 函数
     * @param wait 延迟执行毫秒数
     * @param type 1 表时间戳版，2 表定时器版
     */
    function throttle(func, wait ,type) {
        let previous = 0,timeout
        return function() {
            let context = this;
            let args = arguments;
            if(type===1){
                let now = Date.now();
    
                if (now - previous > wait) {
                    func.apply(context, args);
                    previous = now;
                }
            }else if(type===2){
                if (!timeout) {
                    timeout = setTimeout(() => {
                        timeout = null;
                        func.apply(context, args)
                    }, wait)
                }
            }
        }
    }
    ~~~

+ **图片懒加载**
    1. 如何判断可视区域
    2. 

### 四、vue基础（组件通信，key的作用，生命周期，插槽）包括路由和vuex

+ **v-for中的key值的作用**

  *如果没有写key值在数组修改时不能复用相关组件或节点，造成性能浪费或者一些没必要的错误*

+ **路由原理：**

   > hash模式：通过修改location.hash以及监听hashChange
   >
   > history模式：通过监听popstate
+ **vuex**
1. model直接相互获取state的方法
+ **vue3**
1. vue3中的proxy解决了什么问题

### 五、浏览器相关
+ **浏览器输入url之后发生了什么**
1. DNS域名解析
2. 建立TCP连接（若是HTTPS要进行TLS握手）
3. 请求HTML文件（可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上）
4. 浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错
5. 如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件
6. 渲染流程开始
7. 根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件
8. 遇到文件下载的会去下载文件
9. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西（在这过程中浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了）
+ **浏览器缓存相关**
1. 浏览器缓存分为*强制缓存*和*协商缓存*(浏览器缓存机制即http缓存机制)
    - 强制缓存：向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程
    - 协商缓存：强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程
2. 缓存的规则控制字段
    - 强制缓存：
        1. Cache-Control（*public*->所有内容都将被缓存（客户端和代理服务器都可缓存;
                         *private*->所有内容只有客户端可以缓存，**Cache-Control的默认取值**;
                         *no-cache*->客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定;
                         *no-store*->所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存;
                         *max-age=xxx (xxx is numeric)*->缓存内容将在xxx秒后失效）;
        2. Expires（是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间，即再次发送请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果）
    - 协商缓存
        1. Last-Modified / If-Modified-Since（if-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，）
        2. Etag / If-None-Match（If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200）
3. 总结浏览器缓存过程
    - 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，
    - 若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，
    - 协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；
    - 生效则返回304，继续使用缓存，主要过程如下：![缓存过程](../assets/cache-progress.png)
+ **浏览器垃圾回收机制**
+ **浏览器安全**
1. 跨站脚本攻击（Cross Sites Script）
2. 跨站点请求伪造（Cross Sites Request Forgery）
3. 点击劫持
4. DDOS 攻击
5. SQL 注入
+ **兼容ie具体兼容什么**
1. 不支持html5中的新标签和一些标签的属性值
2. css中flex布局支持不友好（ie10,11），css3以后的相关属性存在兼容问题
3. es6以后的新特性不能得到支持

### 六、http和https(主要的字段含义)

+ **http由请求行、首部、实体组成**

1. 常用首部字段

~~~javascript
// Cache-Control 控制缓存的行为
// Connection 浏览器想要优先使用的连接类型，比如 `keep-alive`
// Date 创建报文时间
// Content-Type 内容的媒体类型
// ......
~~~

2. *2XX 成功*   *3XX 重定向*   *4XX 客户端错误*   *5XX 服务器错误*
3. TLS（HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密）
4. 对称加密（双方都知道私钥）和非对称加密（双方都知道公钥，使用公钥对*真正的密钥*进行加密，服务端用私钥解密获取*真正的密钥*）

### 七、TCP（UDP）/IP

+ **UDP 主要应用于实时性要求较高的数据传输（直播等等）**
+ **TCP三次握手建立连接、四次握手断开连接**

1. 为什么是三次而不是两次？

​      *防止出现失效的连接请求报文段被服务端接收而建立新连接的情况，造成资源的浪费*

### 八、js基础（数据类型、es6、原型链、闭包、promise、JSON）

+ **数据类型**
1. 6 种原始值 `boolean`、`null`、`undefined`、`number`、`string`、`symbol`
2. 对象（object）类型：`Array`、`Date`、`RegExp`、`Function`、`Boolean`、`Number`、`String`
3. 类型转化
   1. 转换规则![类型转换](../assets/js类型转换.png)
   2. 转换方法
       1. if语句和逻辑语句
            > 在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值
       2. 各种数学运算符
            > 我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型；
            + 当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型
            + 当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型
            + 当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接
       3. ==
            + `NaN`和其他任何类型比较永远返回`false`(包括和他自己)
            + **`Boolean`和其他任何类型比较，`Boolean`首先被转换为`Number`类型**
            + `String`和`Number`比较，先将`String`转换为`Number`类型
            + `null` == `undefined`比较结果是`true`，除此之外，`null`、`undefined`和其他任何结果的比较值都为`false`
            + 当原始类型和引用类型做比较时，对象类型会依照`ToPrimitive`（先执行valueOf(),没有继续执行toString()）规则转换为原始类型
4. 判断javaScript的数据类型
   1. typeof
      ~~~ javascript
      // 适用场景
      typeof 'ConardLi'  // string
      typeof 123  // number
      typeof true  // boolean
      typeof Symbol()  // symbol
      typeof undefined  // undefined
      typeof function(){}  // function
      // 不适用场景
      typeof [] // object
      typeof {} // object
      typeof new Date() // object
      typeof /^\d*$/ // object
      typeof null // object 这是在JavaScript初版就流传下来的bug
      ~~~
   2. `instanceof` 操作符可以帮助我们判断引用类型具体是什么类型的对象
      ~~~ javascript
      [] instanceof Array // true
      new Date() instanceof Date // true
      new RegExp() instanceof RegExp // true
      // [] instanceof Array实际上是判断Array.prototype是否在[]的原型链上。
      [] instanceof Object // true
      function(){}  instanceof Object // true
      // 使用instanceof也不能检测基本数据类型
      ~~~
   3. toString
      > 每一个引用类型都有toString方法，默认情况下，`toString()`方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，`toString()` 返回 "[object type]"，其中type是对象的类型。
    
      使用Object上未被覆盖
5. `ECMAScript`中所有的函数的参数都是按值传递的。
6. `symbol`相关规范
    1. 如果我们想创造两个相等的`Symbol`变量，可以使用`Symbol.for(key)`
    2. 当使用`Symbol`作为对象属性时，可以保证对象不会出现重名属性，调用`for...in`不能将其枚举出来，另外调用`Object.getOwnPropertyNames`、`Object.keys()`也不能获取`Symbol`属性
       > 可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。
    3. `symbol`应用：防止XSS（利用JSON不支持`symbol`）、私有属性、防止属性污染
    4. 使用`Symbol("key1")`来创建唯一值变量
7. `number`相关知识（`IEEE 754`标准，使用64位固定长度来表示。）
    1. 运算中精度丢失：由于储存时二进制精度丢失，在这里有了精度丢失导致运算结果精度丢失
        > 常用解决库：[number-precision](https://github.com/nefe/number-precision) 、 [mathjs](https://github.com/josdejong/mathjs/)
    2. 最大最小的安全数`Number.MAX_SAFE_INTEGER` `Number.MIN_SAFE_INTEGER`(2^52);es10中有bigInt
        > 常用解决库：[node-bignum](https://github.com/justmoon/node-bignum) 、 [node-bigint](https://github.com/substack/node-bigint)
                                                                                          >
+ **es6相关**
1. 可迭代协议 与 迭代器协议
2. generators、async/await异步处理
3. let、var、const等的区别
4. 解构赋值
5. proxy（对象用于定义基本操作的自定义行为）

+ **原型链**
1. 原型链就是多个对象通过 `__proto__` 的方式连接了起来

   p1.\_\_proto\_\_ === Player.prototype

   Player.prototype.\_\_proto\_\_ === Function.prototype

   Function.prototype.\_\_proto\_\_ === Object.prototype

2. new 做了些什么

   1. 一个继承自 Player 的新对象 p1 被创建了。

   2. p1.\_\_proto\_\_ = Player.prototype，p1 的\_\_proto\_\_指向 Player 的原型对象

   3. 将 this 指向新创建的对象 p1

   4. 返回这个新对象 p1
      【未显式 return, 返回新对象 p1】
      【显式 return this, 返回新对象 p1】
      【显示 return 基本类型, 返回新对象 p1】
      【显示 return 对象类型（比如一个空对象）, 返回一个空对象。】

+ **闭包**
1. 定义：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包
2. 使用场景：事件的回调，模拟类的私有方法，封装上下文变量

+ **promise**
1. promise三种状态：pending（初始值）、fulfilled（操作成功）、rejected（操作失败）
2. promise一旦新建就会立即执行
3. promise api

+ **JSON**
1. `JSON.stringify()` 中的特殊处理

        属性值为function、Symbol、undefined类型以及对象本身直接隐藏该属性（若出现在数组中用null代替）

### 九、html
+ **DOM 事件流**
1. DOM事件分级：dom0级、dom2级、dom3级
2. DOM2级事件规定的事件流包括三个阶段： （1）事件捕获阶段 （2）处于目标阶段 （3）事件冒泡阶段 
3. DOM0级事件：内联模型添加；脚本模型添加（缺点是同一个节点只能添加一次同类型事件）；只支持冒泡阶段
4. DOM2级事件：
    - addEventListener() 和 removeEventListener()
    - 第三个参数是一个boolean值，默认false表示使用冒泡机制，true表示捕获机制
    - 如果同时允许捕获和冒泡，先执行捕获阶段的处理程序，后执行冒泡阶段的处理程序
    - 触发的目标元素上不区分冒泡还是捕获，按绑定的顺序来执行绑定函数
    - 目标阶段事件对象的stopPropagation(),可以阻止事件传递（**在捕获阶段调用，则整个冒泡阶段都会被阻止**）
5. DOM3级事件：html5新事件api, 拖拽，视频播放，触摸事件
6.事件委托：这时候我们可以将绑定事件委托到需要监听元素的父级元素
    - 事件对象中，target返回触发事件的元素，*不一定是绑定事件的元素*；currentTarget返回的是绑定事件的元素
    - 优点：提高性能（减少函数的声明），动态监听（新增子元素不需要绑定事件）

### 十、css
+ **盒子模型：本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。**
1. 标准模型(box-size:content-box*默认值*)：

        总元素的宽度=宽度(`width`属性)+左填充+右填充+左边框+右边框+左边距+右边距
        
        总元素的高度=高度**(`height`属性)**+顶部填充+底部填充+上边框+下边框+上边距+下边距
2. ie非标准模型(box-size:border-box)

        元素的宽度(`width`属性)=宽度+左填充+右填充+左边框+右边框+左边距+右边距
        
        元素的高度(`height`属性)=高度+顶部填充+底部填充+上边框+下边框+上边距+下边距
        
+ **BFC**
1. BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
2. BFC的布局规则
    1. 内部的Box会在垂直方向，一个接一个地放置。
    2. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。
    3. 每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
    4. BFC的区域不会与float box重叠。
    5. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
    6. 计算BFC的高度时，浮动元素也参与计算。
2. 创建BFC
    1. float的值不是none。
    2. position的值不是static或者relative。
    3. display的值是inline-block、table-cell、flex、table-caption或者inline-flex
    4. overflow的值不是visible
3. BFC的作用
    1. 利用BFC避免margin重叠
    2. 自适应两栏布局
    3. 清除浮动

### 十一、查漏
1. `Number.toString(radix)` 中*radix可选。规定表示数字的基数，使 2 ~ 36 之间的整数。若省略该参数，则使用基数 10*
2. `require()` 可以在运行代码时根据需要加载依赖项-- `import` 是在编译阶段执行，被导入的模块会先执行，导入模块的文件后执行
3. `Number.isNaN()` 会检测传入值是否为数字，如果不是则会返回false，如果是才继续与NaN进行比较； `isNaN()` 会将传入的值转为数值类型再与NaN进行对比
4. `Object.freeze()` 只是对对象进行*浅冻结*
5. 前端不能通过 `document.cookie` 获取cookie的控制字段是 `httpOnly`
6. static的静态方法只在创建它们的构造函数中存在，子级对象无法访问

