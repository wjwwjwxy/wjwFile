1. 计算字符串最后一个单词的长度，单词以空格隔开

   ~~~javascript 
   while(line=readline()){
       var a  = line.lastIndexOf(" ");
       if(a<0){
            print(line.length);
       }else{
           print(line.length -1-a);
       }
   }
   ~~~
2. 连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；
   长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。

   ~~~ javascript
   var lines = [];
   var res = [];
   while(line = readline()){
       lines.push(line)
   }
   for(var k = 0;k<lines.length;k++){
       for(var i = 0; i<lines[k].length;i = i + 8){
           if((i+8)> lines[k].length){
           var lastStr = lines[k].slice(i);
           for(var j = 0;j < (i+8)-lines[k].length;j++){
           lastStr = lastStr + "0"
       }
           res.push(lastStr);
           }else{
               res.push(lines[k].slice(i,i+8))
           }
       }
   }
   for(var m = 0 ;m<res.length;m++){
       print(res[m]);
   }
   ~~~

3. 对字符串中的所有单词进行倒排。
   说明：
   1、每个单词是以26个大写或小写英文字母构成；
   2、非构成单词的字符均视为单词间隔符；
   3、要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符；
   4、每个单词最长20个字母；

   ~~~javascript
   var res = []
   while(line = readline()){
       var arr = line.split(/[^a-zA-Z]/);
       var arr2 = arr.reverse();
       arr2.forEach(function(item){
           if(item){
              res.push(item) 
           }
       })
   }
   print(res.join(' '))
   ~~~

4. 写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。

   ~~~javascript
   var lines = [];
   var count = 0;
   while(line = readline()){
     lines.push(line);
   };
   var testStr = lines[0].toLowerCase();
   
   for(var i = 0;i<testStr.length;i++){
       if(testStr.slice(i,i+1) == lines[1].toLowerCase()){
           count++
       }
   }
   print(count);
   ~~~

5. Catcher是MCA国的情报员，他工作时发现敌国会用一些对称的密码进行通信，
   比如像这些ABBA，ABA，A，123321，但是他们有时会在开始或结束时加入一些无关的字符以防止别国破解。
   比如进行下列变化 ABBA->12ABBA,ABA->ABAKK,123321->51233214　。
   因为截获的串太长了，而且存在多种可能的情况（abaaab可看作是aba,或baaab的加密形式），Cathcer的工作量实在是太大了，
   他只能向电脑高手求助，你能帮Catcher找出最长的有效密码串吗？

   ~~~javascript
   //（待优化）
   function isSn(str){
       for(var i = 0;i<str.length;i++){
           if(str.slice(i,i+1) != str.slice(str.length-i-1,str.length-i)){
               return false;
           }
           if(str.length-i-1-i<=1){
               return true;
           }
       }
   }
   while(line = readline()){
       for(var i = line.length;i>0;i--){
           var isGet = false;
           for(var j = 0;j<=line.length-i;j++){
               if(isSn(line.slice(j,j+i))){
                   print(i);
                   isGet = true;
                   break;
               }
           }
           if(isGet){
               break;
           }
       }
   }
   ~~~
   ~~~ javascript
   // 优化方案，调用该函数即可
   var longestPalindrome = function(s) {
    var getStrMax = ''
    if(s.length <= 1){
        getStrMax = s
    }else{
        getStrMax = s[0]
        for(var i=0;i<s.length-1;i++){
            if(i>0 && s[i] == s[i+1]){
                let getStr = s.substring(i,i+2)
                for(let j = i-1;j>=0;j--){
                    if(s[j] != s[i+i+1-j]){
                        getStr = s.substring(j+1,i+i+1-j)
                        if(getStr.length>getStrMax.length){
                            getStrMax = getStr
                        }
                        break
                    }
                    if(i+i+1-j === s.length-1){
                        getStr = s.substring(j,s.length)
                        if(getStr.length>getStrMax.length){
                            getStrMax = getStr
                        }
                        break
                    }
                    if(j === 0){
                        getStr = s.substring(0,i+i+2)
                        if(getStr.length>getStrMax.length){
                            getStrMax = getStr
                        }
                    }
                }
                if(getStr.length>getStrMax.length){
                    getStrMax = getStr
                }
            } 
            if(i>0 && s[i-1] == s[i+1]){
                let getStr = s.substring(i-1,i+2)
                for(let j = i-2;j>=0;j--){
                    if(s[j] != s[i+i-j]){
                        getStr = s.substring(j+1,i+i-j)
                        if(getStr.length>getStrMax.length){
                            getStrMax = getStr
                        }
                        break
                    }
                    if(i+i-j === s.length-1){
                        getStr = s.substring(j,s.length)
                        if(getStr.length>getStrMax.length){
                            getStrMax = getStr
                        }
                        break
                    }
                    if(j === 0){
                        getStr = s.substring(0,i+i+1)
                        if(getStr.length>getStrMax.length){
                            getStrMax = getStr
                        }
                    }
                }
                if(getStr.length>getStrMax.length){
                    getStrMax = getStr
                }
            } else if(i==0 && s[i] == s[i+1]){
                getStrMax = s.substring(i,i+2)
            }
        }
    }
     return getStrMax
    };
   ~~~

6. 写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。（多组同时输入 ）

   ~~~ javascript
   while(line = readline()){
       print(parseInt(line.slice(2),16))
   }
   ~~~

7. 输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。

   ~~~javascript
   var res = '';
   while(line = readline()){
       for(var i = line.length-1;i>=0;i--){
           if(line.lastIndexOf(line.slice(i,i+1)) == i){
               res = res + line.slice(i,i+1)
           }
       }
       print(res)
   }
   ~~~

8. 二分查找方法

   ~~~javascript
   var Arr = [3, 5, 6, 7, 9, 12, 15];
   function binary(find, arr, low, high) {
       if (low <= high) {
           if (arr[low] == find) {
               return low;
           }
           if (arr[high] == find) {
               return high;
           }
           var mid = Math.ceil((high + low) / 2);
           if (arr[mid] == find) {
               return mid;
           } else if (arr[mid] > find) {
               return binary(find, arr, low, mid - 1);
           } else {
               return binary(find, arr, mid + 1, high);
           }
       }
       return -1;
   }
   binary(15, Arr, 0, Arr.length - 1);	

9. 相关正则

   ~~~javascript
   // "^\\d+$"　　//非负整数（正整数 + 0）
   // "^[0-9]*[1-9][0-9]*$"　　//正整数
   // "^((-\\d+)|(0+))$"　　//非正整数（负整数 + 0）
   // "^-[0-9]*[1-9][0-9]*$"　　//负整数
   // "^-?\\d+$"　　　　//整数
   // "^\\d+(\\.\\d+)?$"　　//非负浮点数（正浮点数 + 0）
   /* "^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0- 9]*[1-9][0-9]*))$"　　//正浮点数 */
   // "^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$"　　//非正浮点数（负浮点数 + 0）
   /* "^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点数 */
   // "^(-?\\d+)(\\.\\d+)?$"　　//浮点数
   ~~~

10. 任意两个正序数组a = [1,2,3,4,8]和b = [2,2,3,4,5,5]以及数字k，满足0<k<a.length * b.length；b.length<1000; c.length<1000; 现将a和b中元素一一配对求和得到新的数组c，求新数组c中前K小的元素之和

