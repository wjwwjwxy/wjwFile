+ **设计模式：**

1. 单例模式

2. 观察者模式{发布-订阅}

3. 代理模式

4. 迭代器模式（封装Ierator）

5. 职责链模式

6. 装饰器模式（面向切面，中间件等）

7. 策略模式

+ **排序算法：**

1. 选择排序（selectionSort）
   核心思想：在当前索引后面遍历寻找最小的数与当前索引对应的值进行交换
   时间复杂度：O(N2)
   相关结论：即使已经排序完的数组也要花费同样的时间

2. 插入排序
   核心思想：当前索引对应的值与之前的数字依次进行比较交换，直到比前面的某个索引对应的值大时停止
   时间复杂度：O(N2)
   最好情况（best case）：O（N）

3. 归并排序
   核心思想：将数组分为两个部分，递归的对两个数组进行排序，然后合并
   时间复杂度：O(NlgN)
   优化方案：数组长度小于等于7的时候用插入排序

4. 快速排序
   核心思想：分区思想，递归实现
   时间复杂度：O(NlgN)
   最坏情况：O(N2)
   优化方案：数组长度小于等于7的时候用插入排序；随机取三个值的中位数作为分区值
   相关结论：快速排序是非稳定的

+ **AST（抽象语法树）**

+ **vue-cli**

1. commander.js(处理用户命令行输入
2. inquire(命令行的表单)

+ **复杂算法**
1. 动态规划（把原问题分级为相对简单的子问题）
   特征：求最值，大部分需要穷举，重叠子问题、具有最优子结构、无后效性，根本目的是解决冗余，难点是状态转移方程
2. 贪心算法（动态规划的一个特例）
   贪心选择性质：保证每步都是最优解

+ **图和树**

+ **前端路由的原理和表现**
1. vue-router路由的匹配是由上往下进行匹配的


